{"meta":{"title":"产","subtitle":"士不可以不弘毅，任重而道远。","description":"士不可以不弘毅，任重而道远。","author":"Kami","url":"https://oldchan.net"},"pages":[{"title":"一个兴趣使然的技术人员","date":"2016-04-29T09:12:41.000Z","updated":"2021-02-25T03:10:06.013Z","comments":false,"path":"about/index.html","permalink":"https://oldchan.net/about/index.html","excerpt":"","text":"MeName: KamiSocial: Github 技能: c/c++、go、php、bash、python、javascript… 等等经历: 熊猫直播 奇虎360 Tools Markdown编辑器"},{"title":"categories","date":"2016-04-29T09:07:56.000Z","updated":"2021-02-20T07:36:21.357Z","comments":false,"path":"categories/index.html","permalink":"https://oldchan.net/categories/index.html","excerpt":"","text":""},{"title":"访客留言","date":"2018-09-09T15:34:08.000Z","updated":"2021-02-24T08:53:21.582Z","comments":true,"path":"guestbook/index.html","permalink":"https://oldchan.net/guestbook/index.html","excerpt":"","text":""},{"title":"history","date":"2018-09-09T15:34:08.000Z","updated":"2021-02-20T07:36:21.139Z","comments":true,"path":"history/index.html","permalink":"https://oldchan.net/history/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-04-29T09:10:18.000Z","updated":"2021-02-20T07:36:21.370Z","comments":false,"path":"tags/index.html","permalink":"https://oldchan.net/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"实现类似class的析构函数","slug":"language/go/struct_like_class","date":"2021-02-20T08:58:58.000Z","updated":"2021-02-24T05:00:51.962Z","comments":true,"path":"2021/02/20/language/go/struct_like_class/","link":"","permalink":"https://oldchan.net/2021/02/20/language/go/struct_like_class/","excerpt":"Go提供的revicer满足函数简单的method操作结构，但并没有提供构造与析构的机制，在有些场景下，我们仍然需要一些能自动释放资源的逻辑。 在Go进程模型中，维护了一种叫finalizer的结构，当内存对象不可访问、需要被GC时，GC程序会检查对象关联的finalizer函数，如果有，则调用一次finalizer函数，并移除关联的finalizer函数，然后该对象再次变成可访问状态，当下一次，该对象再次被GC时，便会被释放并回收。 在runtime包中，对外暴露了一个函数SetFinalizer，用来设置关联的finalizer函数。","text":"Go提供的revicer满足函数简单的method操作结构，但并没有提供构造与析构的机制，在有些场景下，我们仍然需要一些能自动释放资源的逻辑。 在Go进程模型中，维护了一种叫finalizer的结构，当内存对象不可访问、需要被GC时，GC程序会检查对象关联的finalizer函数，如果有，则调用一次finalizer函数，并移除关联的finalizer函数，然后该对象再次变成可访问状态，当下一次，该对象再次被GC时，便会被释放并回收。 在runtime包中，对外暴露了一个函数SetFinalizer，用来设置关联的finalizer函数。 函数: runtime.SetFinalizer1func SetFinalizer(obj interface&#123;&#125;, finalizer interface&#123;&#125;) 构造与析构 定义Initializer接口，约定初始化函数 123type Initializer interface &#123; Init()&#125; 定义Finalizer接口，约定析构函数 123type Finalizer interface &#123; Delete()&#125; 定义InitObject函数用来初始化对象 12345678910111213// Sample: `InitObject(obj)`func InitObject(obj interface&#123;&#125;) &#123; // 如果obj实现了Initializer if ob, ok := obj.(Initializer); ok &#123; ob.Init() &#125; // 如果obj实现了Finalizer if ob, ok := obj.(Finalizer); ok &#123; runtime.SetFinalizer(ob, func(ob Finalizer) &#123; ob.Delete() &#125;) &#125;&#125; Sample12345678910111213141516171819202122232425262728type sample struct &#123;&#125;type Sample struct &#123; *sample&#125;// NewSample returns a Sample.func NewSample() *Sample &#123; // Private object s := &amp;sample&#123;&#125; // Public object obj := &amp;Sample&#123;s&#125; &#123; InitObject(obj) &#125; return obj&#125;// Init方法会在NewSample时，跟随InitObject执行。func (s *sample) Init() &#123; fmt.Printf(\"initialized\\n\")&#125;// Delete方法会在NewSample返回的obj需要被GC时调用。func (s *sample) Delete() &#123; fmt.Printf(\"deleted\\n\")&#125; 注意点 如果对象存在循环引用，可能永远都不会被GC finalizer设置的函数只会在GC时被调用 finalizer函数不适合处理太多耗时逻辑 finalizer函数延长了对象的生命周期，如果不必要，尽量不使用 我在一些项目中用到了自己封装的包，但只有少部分场景下用到了Delete()。 代码包：github.com/thecxx/jarvis","categories":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://oldchan.net/tags/Go/"}],"keywords":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}]},{"title":"Redis数据结构之hash","slug":"redis/type_hash","date":"2018-09-23T13:04:02.000Z","updated":"2021-02-24T05:00:51.992Z","comments":true,"path":"2018/09/23/redis/type_hash/","link":"","permalink":"https://oldchan.net/2018/09/23/redis/type_hash/","excerpt":"hash数据结构在redis缓存中应用比较广泛，一般数据集合都会采用hash结构来进行存储，比如: session数据、在线用户记录等等。","text":"hash数据结构在redis缓存中应用比较广泛，一般数据集合都会采用hash结构来进行存储，比如: session数据、在线用户记录等等。 hash的创建使用hash时最常使用hset用来设置字段(“/src/t_hash.c”文件中)12345678910111213141516171819202122232425262728void hsetCommand(client *c) &#123; int i, created = 0; robj *o; if ((c-&gt;argc % 2) == 1) &#123; addReplyError(c,\"wrong number of arguments for HMSET\"); return; &#125; if ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[1])) == NULL) return; hashTypeTryConversion(o,c-&gt;argv,2,c-&gt;argc-1); for (i = 2; i &lt; c-&gt;argc; i += 2) created += !hashTypeSet(o,c-&gt;argv[i]-&gt;ptr,c-&gt;argv[i+1]-&gt;ptr,HASH_SET_COPY); /* HMSET (deprecated) and HSET return value is different. */ char *cmdname = c-&gt;argv[0]-&gt;ptr; if (cmdname[1] == 's' || cmdname[1] == 'S') &#123; /* HSET */ addReplyLongLong(c, created); &#125; else &#123; /* HMSET */ addReply(c, shared.ok); &#125; signalModifiedKey(c-&gt;db,c-&gt;argv[1]); notifyKeyspaceEvent(NOTIFY_HASH,\"hset\",c-&gt;argv[1],c-&gt;db-&gt;id); server.dirty++;&#125; hset执行时，首先会检查k-v对的数量是否匹配 然后查询客户端对应的当前db，查找key对应结构(没有则创建一个ziplist的结构对象) 获取到结果，再通过hashTypeTryConversion函数尝试转换为dict结构(根据参数值大小决定) hsetCommand结构根据参数的数量，可以同时支持hset与hmset 常用命令参考: Hash","categories":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://oldchan.net/tags/redis/"}],"keywords":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}]},{"title":"PE文件加载器","slug":"windows/pe/pe_loader","date":"2018-09-10T13:39:49.000Z","updated":"2021-02-24T05:00:52.012Z","comments":true,"path":"2018/09/10/windows/pe/pe_loader/","link":"","permalink":"https://oldchan.net/2018/09/10/windows/pe/pe_loader/","excerpt":"分享一份自己之前总结以前的代码写的dll内存加载库C++版本项目要自行编译生成lib文件 支持： Win32标准Dll MFC Dll 易语言Dll 其他环境下生成的Dll但 不能加壳加密(原因跟加载方式有关，未添加至进程模块链表)","text":"分享一份自己之前总结以前的代码写的dll内存加载库C++版本项目要自行编译生成lib文件 支持： Win32标准Dll MFC Dll 易语言Dll 其他环境下生成的Dll但 不能加壳加密(原因跟加载方式有关，未添加至进程模块链表) 部分代码File: include/ldr.h1234567891011121314151617181920212223242526272829/* __ldr_header__ */#ifndef __LDR_H__#define __LDR_H__#ifdef _DEBUG#pragma comment(lib, \"image.d.lib\")#else#pragma comment(lib, \"image.lib\")#endif#ifdef _WIN32#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;tchar.h&gt;#include &lt;Windows.h&gt;#include &lt;WinNT.h&gt;#else#error Current platform is not supported#endiftypedef PVOID (__stdcall *malloc_t) (ULONG);typedef VOID (__stdcall *free_t) (PVOID);PVOID LdrLoadImage (PVOID Buffer, DWORD Size, malloc_t m = NULL, free_t f = NULL);PVOID LdrGetProcAddress (PVOID Addr, LPCSTR Name);VOID LdrFreeImage (PVOID Addr);#endif File: image/traps/GetModuleHandleW.asm 加入汇编代码主要是为了做中间层hook处理，否则非正常加载的模块部分接口不可用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.386.Model flat, StdCallOption CaseMap: none Include trap.inc .Const .Data? .Data .Code GetModuleHandleWTrap Proc Uses Ebx Ecx Edx Esi Edi, lpModuleName: Ptr WCHAR ; Mov Esi, 0x******** Mov_Esi_Information ; Pointer to ImageInformation Assume Esi: Ptr ImageInformation .If lpModuleName == 0 Push 0 Call [Esi].traps[SizeOf ImageTrap * TRAP_ID_GET_MODULE_HANDLE_W].procedure .Else Lea Ebx, [Esi].ModuleNameW Push Ebx Push lpModuleName Call [Esi].apis.lstrcmpiW Cmp Eax, 0 Je __COPY Lea Ebx, [Esi].ModuleBaseNameW Push Ebx Push lpModuleName Call [Esi].apis.lstrcmpiW Cmp Eax, 0 Jne __CALL __COPY: Mov Eax, [Esi].imagebase Jmp @F __CALL: Push lpModuleName Call [Esi].traps[SizeOf ImageTrap * TRAP_ID_GET_MODULE_HANDLE_W].procedure @@: .EndIf Return EaxGetModuleHandleWTrap EndP End 使用接口(对应关系) LdrLoadImage = LoadLibrary LdrGetProcAddress = GetProcAddress LdrFreeImage = FreeLibrary 项目地址https://github.com/thecxx/image","categories":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://oldchan.net/tags/Windows/"}],"keywords":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}]},{"title":"Redis中常用数据结构","slug":"redis/types","date":"2018-09-10T12:56:40.000Z","updated":"2021-02-24T05:00:52.005Z","comments":true,"path":"2018/09/10/redis/types/","link":"","permalink":"https://oldchan.net/2018/09/10/redis/types/","excerpt":"redis不仅支持最简单的k-v数据，还提供其他多种场景可用的数据结构: hash/list/set/zset等等。 hash list set zset","text":"redis不仅支持最简单的k-v数据，还提供其他多种场景可用的数据结构: hash/list/set/zset等等。 hash list set zset redis数据存储redis维护的db数据结构12345678910typedef struct redisDb &#123; dict *dict; /* The keyspace for this DB */ dict *expires; /* Timeout of keys with a timeout set */ dict *blocking_keys; /* Keys with clients waiting for data (BLPOP)*/ dict *ready_keys; /* Blocked keys that received a PUSH */ dict *watched_keys; /* WATCHED keys for MULTI/EXEC CAS */ int id; /* Database ID */ long long avg_ttl; /* Average TTL, just for stats */ list *defrag_later; /* List of key names to attempt to defrag one by one, gradually. */&#125; redisDb; dict: 保存的是当前db中所有key的一个dict结构 从一个指定db的dict结构中查找到对应redisObject结构的对象123456789typedef struct redisObject &#123; unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ int refcount; void *ptr;&#125; robj; 通过给定的命令，检查数据是否可操作 redis默认db数量为16","categories":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://oldchan.net/tags/redis/"}],"keywords":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}]},{"title":"Go语言监听进程退出信号","slug":"language/go/when_process_exit","date":"2018-09-10T11:14:30.000Z","updated":"2021-02-24T08:54:43.388Z","comments":true,"path":"2018/09/10/language/go/when_process_exit/","link":"","permalink":"https://oldchan.net/2018/09/10/language/go/when_process_exit/","excerpt":"项目中经常需要在进程退出时处理一些资源回收操作，打开的资源需要关闭，创建的临时数据需要销毁等等…","text":"项目中经常需要在进程退出时处理一些资源回收操作，打开的资源需要关闭，创建的临时数据需要销毁等等… 实现过程通过os/signal包来获取进程信号接收管道，用一个goroutine来等待指定的信号 1234567891011121314151617181920212223242526272829303132333435package utilsimport ( \"os\" \"os/signal\" \"syscall\")var ( exitHandlers []func(os.Signal))// 捕获进程退出信号，执行回调func WhenExit(handler func(os.Signal)) &#123; if len(exitHandlers) == 0 &#123; ch := make(chan os.Signal) sigs := []os.Signal&#123; syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGUSR1, syscall.SIGUSR2, &#125; signal.Notify(ch, sigs...) go func() &#123; s := &lt;-ch for _, handler := range exitHandlers &#123; handler(s) &#125; &#125;() &#125; // 增加退出回调 exitHandlers = append(exitHandlers, handler)&#125; 使用方法123WhenExit(func(sig os.Signal) &#123; // @todo something&#125;)","categories":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://oldchan.net/tags/Go/"}],"keywords":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}]},{"title":"浅析redis启动流程","slug":"redis/startup","date":"2018-08-24T02:42:16.000Z","updated":"2021-02-24T10:56:57.765Z","comments":true,"path":"2018/08/24/redis/startup/","link":"","permalink":"https://oldchan.net/2018/08/24/redis/startup/","excerpt":"阅读了下redis的源代码，了解一下服务的启动流程。","text":"阅读了下redis的源代码，了解一下服务的启动流程。 程序入口mainmain函数做为c语言程序入口，redis中的main函数在文件”/src/server.c”中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240int main(int argc, char **argv) &#123; struct timeval tv; int j;#ifdef REDIS_TEST if (argc == 3 &amp;&amp; !strcasecmp(argv[1], \"test\")) &#123; if (!strcasecmp(argv[2], \"ziplist\")) &#123; return ziplistTest(argc, argv); &#125; else if (!strcasecmp(argv[2], \"quicklist\")) &#123; quicklistTest(argc, argv); &#125; else if (!strcasecmp(argv[2], \"intset\")) &#123; return intsetTest(argc, argv); &#125; else if (!strcasecmp(argv[2], \"zipmap\")) &#123; return zipmapTest(argc, argv); &#125; else if (!strcasecmp(argv[2], \"sha1test\")) &#123; return sha1Test(argc, argv); &#125; else if (!strcasecmp(argv[2], \"util\")) &#123; return utilTest(argc, argv); &#125; else if (!strcasecmp(argv[2], \"sds\")) &#123; return sdsTest(argc, argv); &#125; else if (!strcasecmp(argv[2], \"endianconv\")) &#123; return endianconvTest(argc, argv); &#125; else if (!strcasecmp(argv[2], \"crc64\")) &#123; return crc64Test(argc, argv); &#125; return -1; /* test not found */ &#125;#endif /* We need to initialize our libraries, and the server configuration. */#ifdef INIT_SETPROCTITLE_REPLACEMENT spt_init(argc, argv);#endif // 设置本地化 setlocale(LC_COLLATE,\"\"); // 设置时区 tzset(); /* Populates 'timezone' global. */ // OOM保护机制的处理接口 zmalloc_set_oom_handler(redisOutOfMemoryHandler); // 生成随机种子 srand(time(NULL)^getpid()); // 获取时间 gettimeofday(&amp;tv,NULL); // 生成一个随机16位长度字符串，用于后续使用生成hash(siphash)值时 char hashseed[16]; getRandomHexChars(hashseed,sizeof(hashseed)); dictSetHashFunctionSeed((uint8_t*)hashseed); // 检测是否启用sentinel server.sentinel_mode = checkForSentinelMode(argc,argv); // 初始化服务器配置 initServerConfig(); // 初始化模块系统 moduleInitModulesSystem(); /* Store the executable path and arguments in a safe place in order * to be able to restart the server later. */ server.executable = getAbsolutePath(argv[0]); server.exec_argv = zmalloc(sizeof(char*)*(argc+1)); server.exec_argv[argc] = NULL; for (j = 0; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]); // 如果需要启动sentinel，则进行sentinel的初始化工作 /* We need to init sentinel right now as parsing the configuration file * in sentinel mode will have the effect of populating the sentinel * data structures with master nodes to monitor. */ if (server.sentinel_mode) &#123; initSentinelConfig(); initSentinel(); &#125; // 如只需检测rdb/aof是否正常可用，则检测完退出启动流程 /* Check if we need to start in redis-check-rdb/aof mode. We just execute * the program main. However the program is part of the Redis executable * so that we can easily execute an RDB check on loading errors. */ if (strstr(argv[0],\"redis-check-rdb\") != NULL) redis_check_rdb_main(argc,argv,NULL); else if (strstr(argv[0],\"redis-check-aof\") != NULL) redis_check_aof_main(argc,argv); if (argc &gt;= 2) &#123; j = 1; /* First option to parse in argv[] */ sds options = sdsempty(); char *configfile = NULL; // 查看版本/help相关操作，会在执行之后退出启动流程 /* Handle special options --help and --version */ if (strcmp(argv[1], \"-v\") == 0 || strcmp(argv[1], \"--version\") == 0) version(); if (strcmp(argv[1], \"--help\") == 0 || strcmp(argv[1], \"-h\") == 0) usage(); if (strcmp(argv[1], \"--test-memory\") == 0) &#123; if (argc == 3) &#123; memtest(atoi(argv[2]),50); exit(0); &#125; else &#123; fprintf(stderr,\"Please specify the amount of memory to test in megabytes.\\n\"); fprintf(stderr,\"Example: ./redis-server --test-memory 4096\\n\\n\"); exit(1); &#125; &#125; // 命令行参数格式: --参数名(上面-v/-h等参数特殊处理除外) // 第一个参数必须是非\"--\"前缀格式才做为配置文件解析 /* First argument is the config file name? */ if (argv[j][0] != '-' || argv[j][1] != '-') &#123; configfile = argv[j]; server.configfile = getAbsolutePath(configfile); /* Replace the config file in server.exec_argv with * its absolute path. */ zfree(server.exec_argv[j]); server.exec_argv[j] = zstrdup(server.configfile); j++; &#125; /* All the other options are parsed and conceptually appended to the * configuration file. For instance --port 6380 will generate the * string \"port 6380\\n\" to be parsed after the actual file name * is parsed, if any. */ while(j != argc) &#123; if (argv[j][0] == '-' &amp;&amp; argv[j][1] == '-') &#123; /* Option name */ if (!strcmp(argv[j], \"--check-rdb\")) &#123; /* Argument has no options, need to skip for parsing. */ j++; continue; &#125; if (sdslen(options)) options = sdscat(options,\"\\n\"); options = sdscat(options,argv[j]+2); options = sdscat(options,\" \"); &#125; else &#123; /* Option argument */ options = sdscatrepr(options,argv[j],strlen(argv[j])); options = sdscat(options,\" \"); &#125; j++; &#125; if (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == '-') &#123; serverLog(LL_WARNING, \"Sentinel config from STDIN not allowed.\"); serverLog(LL_WARNING, \"Sentinel needs config file on disk to save state. Exiting...\"); exit(1); &#125; resetServerSaveParams(); // 加载配置文件，同时会将命令行参数追加到配置中，解析配置时会进行覆盖 loadServerConfig(configfile,options); sdsfree(options); &#125; serverLog(LL_WARNING, \"oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\"); serverLog(LL_WARNING, \"Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started\", REDIS_VERSION, (sizeof(long) == 8) ? 64 : 32, redisGitSHA1(), strtol(redisGitDirty(),NULL,10) &gt; 0, (int)getpid()); if (argc == 1) &#123; serverLog(LL_WARNING, \"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf\", argv[0], server.sentinel_mode ? \"sentinel\" : \"redis\"); &#125; else &#123; serverLog(LL_WARNING, \"Configuration loaded\"); &#125; // 检查是否启用后台进程，如果启用则当前进程将在创建子进程成功之后退出 server.supervised = redisIsSupervised(server.supervised_mode); int background = server.daemonize &amp;&amp; !server.supervised; if (background) daemonize(); // 初始化服务器各项结构 initServer(); if (background || server.pidfile) createPidFile(); redisSetProcTitle(argv[0]); redisAsciiArt(); checkTcpBacklogSettings(); if (!server.sentinel_mode) &#123; /* Things not needed when running in Sentinel mode. */ serverLog(LL_WARNING,\"Server initialized\"); #ifdef __linux__ linuxMemoryWarnings(); #endif // 通过模块队列加载模块 moduleLoadFromQueue(); // 通过aof/rdb加载数据 loadDataFromDisk(); if (server.cluster_enabled) &#123; if (verifyClusterConfigWithData() == C_ERR) &#123; serverLog(LL_WARNING, \"You can't have keys in a DB different than DB 0 when in \" \"Cluster mode. Exiting.\"); exit(1); &#125; &#125; if (server.ipfd_count &gt; 0) serverLog(LL_NOTICE,\"Ready to accept connections\"); if (server.sofd &gt; 0) serverLog(LL_NOTICE,\"The server is now ready to accept connections at %s\", server.unixsocket); &#125; else &#123; sentinelIsRunning(); &#125; /* Warning the user about suspicious maxmemory setting. */ if (server.maxmemory &gt; 0 &amp;&amp; server.maxmemory &lt; 1024*1024) &#123; serverLog(LL_WARNING,\"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?\", server.maxmemory); &#125; // 进入主循环的一次回调 aeSetBeforeSleepProc(server.el,beforeSleep); // 监听到事件之后的一次回调 aeSetAfterSleepProc(server.el,afterSleep); // 开启事件循环 aeMain(server.el); aeDeleteEventLoop(server.el); return 0;&#125; 事件循环aeMain服务启动之后，初始化完毕，就开始执行事件循环系统(“/src/ae.c”文件中)123456789void aeMain(aeEventLoop *eventLoop) &#123; eventLoop-&gt;stop = 0; while (!eventLoop-&gt;stop) &#123; if (eventLoop-&gt;beforesleep != NULL) eventLoop-&gt;beforesleep(eventLoop); // 处理事件 aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP); &#125;&#125; 循环前的beforesleep关于beforesleep的代码也整理出来看看12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* This function gets called every time Redis is entering the * main loop of the event driven library, that is, before to sleep * for ready file descriptors. */void beforeSleep(struct aeEventLoop *eventLoop) &#123; UNUSED(eventLoop); /* Call the Redis Cluster before sleep function. Note that this function * may change the state of Redis Cluster (from ok to fail or vice versa), * so it's a good idea to call it before serving the unblocked clients * later in this function. */ if (server.cluster_enabled) clusterBeforeSleep(); // Key过期处理 /* Run a fast expire cycle (the called function will return * ASAP if a fast cycle is not needed). */ if (server.active_expire_enabled &amp;&amp; server.masterhost == NULL) activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST); // 跟slave库的联系/数据的同步等等 /* Send all the slaves an ACK request if at least one client blocked * during the previous event loop iteration. */ if (server.get_ack_from_slaves) &#123; robj *argv[3]; argv[0] = createStringObject(\"REPLCONF\",8); argv[1] = createStringObject(\"GETACK\",6); argv[2] = createStringObject(\"*\",1); /* Not used argument. */ replicationFeedSlaves(server.slaves, server.slaveseldb, argv, 3); decrRefCount(argv[0]); decrRefCount(argv[1]); decrRefCount(argv[2]); server.get_ack_from_slaves = 0; &#125; // 处理上一个循环中未响应完的处理 /* Unblock all the clients blocked for synchronous replication * in WAIT. */ if (listLength(server.clients_waiting_acks)) processClientsWaitingReplicas(); /* Check if there are clients unblocked by modules that implement * blocking commands. */ moduleHandleBlockedClients(); /* Try to process pending commands for clients that were just unblocked. */ if (listLength(server.unblocked_clients)) processUnblockedClients(); // aof的处理(不是执行一条命令就追加一条，是在一个循环完，开始一个新的循环之前落地到磁盘) /* Write the AOF buffer on disk */ flushAppendOnlyFile(0); /* Handle writes with pending output buffers. */ handleClientsWithPendingWrites(); /* Before we are going to sleep, let the threads access the dataset by * releasing the GIL. Redis main thread will not touch anything at this * time. */ if (moduleCount()) moduleReleaseGIL();&#125; 事件处理aeProcessEvents系统主要处理两种事件: 一种时间事件，一种网络事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/* Process every pending time event, then every pending file event * (that may be registered by time event callbacks just processed). * Without special flags the function sleeps until some file event * fires, or when the next time event occurs (if any). * * If flags is 0, the function does nothing and returns. * if flags has AE_ALL_EVENTS set, all the kind of events are processed. * if flags has AE_FILE_EVENTS set, file events are processed. * if flags has AE_TIME_EVENTS set, time events are processed. * if flags has AE_DONT_WAIT set the function returns ASAP until all * if flags has AE_CALL_AFTER_SLEEP set, the aftersleep callback is called. * the events that's possible to process without to wait are processed. * * The function returns the number of events processed. */int aeProcessEvents(aeEventLoop *eventLoop, int flags)&#123; int processed = 0, numevents; /* Nothing to do? return ASAP */ if (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) return 0; /* Note that we want call select() even if there are no * file events to process as long as we want to process time * events, in order to sleep until the next time event is ready * to fire. */ if (eventLoop-&gt;maxfd != -1 || ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123; int j; aeTimeEvent *shortest = NULL; struct timeval tv, *tvp; if (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT)) shortest = aeSearchNearestTimer(eventLoop); if (shortest) &#123; long now_sec, now_ms; aeGetTime(&amp;now_sec, &amp;now_ms); tvp = &amp;tv; /* How many milliseconds we need to wait for the next * time event to fire? */ long long ms = (shortest-&gt;when_sec - now_sec)*1000 + shortest-&gt;when_ms - now_ms; if (ms &gt; 0) &#123; tvp-&gt;tv_sec = ms/1000; tvp-&gt;tv_usec = (ms % 1000)*1000; &#125; else &#123; tvp-&gt;tv_sec = 0; tvp-&gt;tv_usec = 0; &#125; &#125; else &#123; /* If we have to check for events but need to return * ASAP because of AE_DONT_WAIT we need to set the timeout * to zero */ if (flags &amp; AE_DONT_WAIT) &#123; tv.tv_sec = tv.tv_usec = 0; tvp = &amp;tv; &#125; else &#123; /* Otherwise we can block */ tvp = NULL; /* wait forever */ &#125; &#125; // tvp是等待时间，是距离下一个最近的时间事件的时间距离 // redis的循环事件是不等待的 // aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP); /* Call the multiplexing API, will return only on timeout or when * some event fires. */ numevents = aeApiPoll(eventLoop, tvp); /* After sleep callback. */ if (eventLoop-&gt;aftersleep != NULL &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP) eventLoop-&gt;aftersleep(eventLoop); for (j = 0; j &lt; numevents; j++) &#123; aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd]; int mask = eventLoop-&gt;fired[j].mask; int fd = eventLoop-&gt;fired[j].fd; int fired = 0; /* Number of events fired for current fd. */ /* Normally we execute the readable event first, and the writable * event laster. This is useful as sometimes we may be able * to serve the reply of a query immediately after processing the * query. * * However if AE_BARRIER is set in the mask, our application is * asking us to do the reverse: never fire the writable event * after the readable. In such a case, we invert the calls. * This is useful when, for instance, we want to do things * in the beforeSleep() hook, like fsynching a file to disk, * before replying to a client. */ int invert = fe-&gt;mask &amp; AE_BARRIER; /* Note the \"fe-&gt;mask &amp; mask &amp; ...\" code: maybe an already * processed event removed an element that fired and we still * didn't processed, so we check if the event is still valid. * * Fire the readable event if the call sequence is not * inverted. */ if (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123; fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; &#125; /* Fire the writable event. */ if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123; if (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123; fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; &#125; &#125; /* If we have to invert the call, fire the readable event now * after the writable one. */ if (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123; if (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123; fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; &#125; &#125; processed++; &#125; &#125; /* Check time events */ if (flags &amp; AE_TIME_EVENTS) // 处理时间事件 processed += processTimeEvents(eventLoop); return processed; /* return the number of processed file/time events */&#125; 简单总结 主程序中进行各项程序初始化/服务初始化/模块初始化等等 系统初始化结束启动事件循环系统 对于客户端的相关读写操作均才用单线程模式处理 对于部分低级别任务采用后台线程异步处理","categories":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://oldchan.net/tags/redis/"}],"keywords":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}]},{"title":"静态博客实现动态交互","slug":"blog/interaction","date":"2017-08-30T06:05:57.000Z","updated":"2021-02-24T08:57:58.709Z","comments":true,"path":"2017/08/30/blog/interaction/","link":"","permalink":"https://oldchan.net/2017/08/30/blog/interaction/","excerpt":"静态博客没有动态的脚本，都是html/js/css形式的文件组成，想要实现动态的交互，需要借助第三方的一些渠道来实现。在之前，我的博客都是使用多说(服务已经关闭)来做动态评论，但是今天发现多说原来已经关闭了，于是重新找了一个替代服务：搜狐畅言。","text":"静态博客没有动态的脚本，都是html/js/css形式的文件组成，想要实现动态的交互，需要借助第三方的一些渠道来实现。在之前，我的博客都是使用多说(服务已经关闭)来做动态评论，但是今天发现多说原来已经关闭了，于是重新找了一个替代服务：搜狐畅言。 申请畅言帐号首先，进去搜狐畅言注册帐号，按照提示，一步一步对自己的站点做好配置，主要的一点是，畅言的站点必须备案过，还要过审核还能正常使用，不然只能使用15天。 安装畅言代码对于外挂式评论功能模块，都会提供一份嵌入代码，畅言也在帐号的管理后台提供了一份嵌入代码，代码提供三中平台使用，PC、WAP、自适应，我选择使用自适应的那份代码。 12345678910111213141516171819202122232425262728293031323334353637&lt;!--PC和WAP自适应版--&gt;&lt;div id=\"SOHUCS\" &gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; (function()&#123; var appid = '畅言帐号提供的应用ID'; var conf = '畅言帐号提供的配置ID'; var width = window.innerWidth || document.documentElement.clientWidth; if (width &lt; 960) &#123; window.document.write('&lt;script id=\"changyan_mobile_js\" charset=\"utf-8\" type=\"text/javascript\" src=\"https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&amp;conf=' + conf + '\"&gt;&lt;\\/script&gt;'); &#125; else &#123; var loadJs=function(d, a) &#123; var c = document.getElementsByTagName(\"head\")[0] || document.head || document.documentElement; var b = document.createElement(\"script\"); b.setAttribute(\"type\",\"text/javascript\"); b.setAttribute(\"charset\",\"UTF-8\"); b.setAttribute(\"src\",d); if(typeof a === \"function\") &#123; if(window.attachEvent) &#123; b.onreadystatechange = function() &#123; var e = b.readyState; if(e === \"loaded\" || e === \"complete\") &#123; b.onreadystatechange = null; a() &#125; &#125; &#125; else &#123; b.onload =a &#125; &#125; c.appendChild(b) &#125;; loadJs(\"https://changyan.sohu.com/upload/changyan.js\", function() &#123; window.changyan.api.config(&#123;appid:appid,conf:conf&#125;) &#125;); &#125; &#125;)();&lt;/script&gt; 以上代码，嵌入到需要使用评论框的地方即可。 评论管理到这里，任何在博客里评论的内容都能通过畅言的后台进行管理了，另外畅言还提供一些其他的互动功能，包括任务、点赞之类的功能也比较丰富。其次，畅言还提供一个chrome扩展用来方便的直接在博客页面管理评论。","categories":[{"name":"Unclassified","slug":"Unclassified","permalink":"https://oldchan.net/categories/Unclassified/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://oldchan.net/tags/博客/"}],"keywords":[{"name":"Unclassified","slug":"Unclassified","permalink":"https://oldchan.net/categories/Unclassified/"}]},{"title":"test命令","slug":"linux/cmds/test","date":"2017-06-23T05:29:56.000Z","updated":"2021-02-24T08:54:55.732Z","comments":true,"path":"2017/06/23/linux/cmds/test/","link":"","permalink":"https://oldchan.net/2017/06/23/linux/cmds/test/","excerpt":"test命令在Linux下一般位置是/usr/bin/test，Mac系统下是shell内置指令。 test命令还有一个别名指令”[“，Linux下一般位置是”/usr/bin/[“，Mac系统下是shell内置指令。","text":"test命令在Linux下一般位置是/usr/bin/test，Mac系统下是shell内置指令。 test命令还有一个别名指令”[“，Linux下一般位置是”/usr/bin/[“，Mac系统下是shell内置指令。 指令描述 作用：检查条件是否成立方法：test 条件 或 [ 条件 ]用例:12345if [ -d ~ ]; then echo \"It's a directory\"fi# 或者以下test -d ~ &amp;&amp; echo \"It's a directory\" 指令帮助 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990-b file True if file exists and is a block special file.-c file True if file exists and is a character special file.-d file True if file exists and is a directory.-e file True if file exists (regardless of type).-f file True if file exists and is a regular file.-g file True if file exists and its set group ID flag is set.-h file True if file exists and is a symbolic link. This operator is retained for compatibility with previous versions of this program. Do not rely on its existence; use -L instead.-k file True if file exists and its sticky bit is set.-n string True if the length of string is nonzero.-p file True if file is a named pipe (FIFO).-r file True if file exists and is readable.-s file True if file exists and has a size greater than zero.-t file_descriptor True if the file whose file descriptor number is file_descriptor is open and is associated with a terminal.-u file True if file exists and its set user ID flag is set.-w file True if file exists and is writable. True indicates only that the write flag is on. The file is not writable on a read-only file system even if this test indicates true.-x file True if file exists and is executable. True indicates only that the execute flag is on. If file is a directory, true indicates that file can be searched.-z string True if the length of string is zero.-L file True if file exists and is a symbolic link.-O file True if file exists and its owner matches the effective user id of this process.-G file True if file exists and its group matches the effective group id of this process.-S file True if file exists and is a socket.file1 -nt file2 True if file1 exists and is newer than file2.file1 -ot file2 True if file1 exists and is older than file2.file1 -ef file2 True if file1 and file2 exist and refer to the same file.string True if string is not the null string.s1 = s2 True if the strings s1 and s2 are identical.s1 != s2 True if the strings s1 and s2 are not identical.s1 &lt; s2 True if string s1 comes before s2 based on the ASCII value of their characters.s1 &gt; s2 True if string s1 comes after s2 based on the ASCII value of their characters.n1 -eq n2 True if the integers n1 and n2 are algebraically equal.n1 -ne n2 True if the integers n1 and n2 are not algebraically equal.n1 -gt n2 True if the integer n1 is algebraically greater than the integer n2.n1 -ge n2 True if the integer n1 is algebraically greater than or equal to the integer n2.n1 -lt n2 True if the integer n1 is algebraically less than the integer n2.n1 -le n2 True if the integer n1 is algebraically less than or equal to the integer n2.These primaries can be combined with the following operators:! expression True if expression is false.expression1 -a expression2 True if both expression1 and expression2 are true.expression1 -o expression2 True if either expression1 or expression2 are true.(expression) True if expression is true.The -a operator has higher precedence than the -o operator. 执行结果 1234567The test utility exits with one of the following values:0 expression evaluated to true.1 expression evaluated to false or expression was missing.&gt;1 An error occurred.","categories":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"https://oldchan.net/tags/Linux命令/"}],"keywords":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}]},{"title":"top命令","slug":"linux/cmds/top","date":"2017-01-21T17:15:44.000Z","updated":"2021-02-24T08:55:05.329Z","comments":true,"path":"2017/01/22/linux/cmds/top/","link":"","permalink":"https://oldchan.net/2017/01/22/linux/cmds/top/","excerpt":"top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。 top显示系统当前的进程和其他状况,是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止. 比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。","text":"top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。 top显示系统当前的进程和其他状况,是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止. 比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。 显示样例 1234567891011121314top - 16:38:41 up 7 days, 2:08, 1 user, load average: 0.00, 0.00, 0.00Tasks: 7 total, 1 running, 6 sleeping, 0 stopped, 0 zombieCpu(s): 0.0%us, 0.0%sy, 0.0%ni,100.0%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%stMem: 2047428k total, 316208k used, 1731220k free, 17088k buffersSwap: 4093948k total, 0k used, 4093948k free, 186184k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 3128 1344 1044 S 0.0 0.1 0:00.06 init 9 root 20 0 97.7m 15m 6032 S 0.0 0.8 0:01.61 supervisord 12 root 20 0 66296 5748 5032 S 0.0 0.3 0:00.02 sshd 14 root 20 0 167m 2584 2220 S 0.0 0.1 0:00.10 rsyslogd 34 root 20 0 98496 6988 5996 S 0.0 0.3 0:00.03 sshd 36 root 20 0 13032 3080 2744 S 0.0 0.2 0:00.00 bash 47 root 20 0 14948 1972 1764 R 0.0 0.1 0:00.00 top 各项信息解释 统计信息区 系统整体状况 16:38:41: 当前系统时间 up 7 days, 2:08: 系统运行时间，即从启动开始到现在为止运行多长时间 1 user: 当前登录用户数量 load average: 0.00, 0.00, 0.00: 系统负载，即任务队列的平均长度。三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。 进程信息 7 total: 进程总数 1 running: 正在运行中的进程数 6 sleeping: 睡眠中的进程数 0 stopped: 停止的进程数 0 zombie: 僵尸进程数 CPU信息 0.0%us: 用户空间占用cpu百分比 0.0%sy: 内核空间占用cpu百分比 0.0%ni: 用户进程空间内改变过优先级的进程占用cpu百分比 100.0%id: 空间cpu百分比 0.0%wa: 等待输入输出的cpu时间百分比 0.0%hi: 硬中断占用百分比 0.0%si: 软中断占用百分比 0.0%st: 虚拟机占用百分比 内存信息 2047428k total: 物理内存总量 316208k used: 已用物理内存总量 1731220k free: 空闲内存总量 17088k buffers: 用于内核缓存的内存使用量 交换分区信息 4093948k total: 交换区总量 0k used: 使用的交换区总量 4093948k free: 空闲交换区总量 186184k cached: 缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小,相应的内存再次被换出时可不必再对交换区写入 进程信息区 PID: 进程id USER: 进程所有者的用户名 PR: 优先级 NI: 负值表示高优先级，正值表示低优先级 VIRT: 进程使用的虚拟内存总量，单位kb RES: 进程使用的、未被换出的物理内存大小 SHR: 共享内存大小，单位kb S: 进程状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程) %CPU: 上次更新到现在的CPU时间占用百分比 %MEM: 进程使用的物理内存百分比 TIME+: 进程使用的CPU时间总计，单位1/100秒 COMMAND: 命令名/命令行 命令说明 执行命令 Usage: top -hv | -abcHimMsS -d delay -n iterations [-u user | -U user] -p pid [,pid ...] 常用参数说明 d: 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。 p: 通过指定监控进程ID来仅仅监控某个进程的状态。 q: 该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。 S: 指定累计模式 s: 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。 i: 使top不显示任何闲置或者僵死进程。 c: 显示整个命令行而不只是显示命令名 交互指令 h|?: 显示帮助画面，给出一些简短的命令总结说明。 k: 终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。 i: 忽略闲置和僵死进程。这是一个开关式命令。 q: 退出程序。 r: 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。 S: 切换到累计模式。 s: 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。 f|F: 从当前显示中添加或者删除项目。 o|O: 改变显示项目的顺序。 l: 切换显示平均负载和启动时间信息。 m: 切换显示内存信息。 t: 切换显示进程和CPU状态信息。 c: 切换显示命令名称和完整命令行。 M: 根据驻留内存大小进行排序。 P: 根据CPU使用百分比大小进行排序。 T: 根据时间/累计时间进行排序。 W: 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。","categories":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"https://oldchan.net/tags/Linux命令/"}],"keywords":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}]},{"title":"借助Hexo搭建静态博客","slug":"blog/static_blog","date":"2017-01-19T05:53:48.000Z","updated":"2021-02-24T05:00:51.958Z","comments":true,"path":"2017/01/19/blog/static_blog/","link":"","permalink":"https://oldchan.net/2017/01/19/blog/static_blog/","excerpt":"静态博客顾名思义就是博客内容是静态的html页面，不是由服务器程序(php、java等等)生成的页面，而是由专门的生成系统工具根据博客内容加上指定的模版生成的一套静态页面。 静态博客的特点 部署方便局限性小，因为是静态页面，因此只需要提供一个能访问的web空间即可，目前大部分的git平台都 免费 提供这么一个服务，让用户可以将静态页面托管在服务器上提供外部访问 对于静态博客而言，方便部署是一个优势，但静态页面总会缺乏交互性，没有数据库，没有服务器的应答脚本，但是做为普通的个人博客却已经足够了","text":"静态博客顾名思义就是博客内容是静态的html页面，不是由服务器程序(php、java等等)生成的页面，而是由专门的生成系统工具根据博客内容加上指定的模版生成的一套静态页面。 静态博客的特点 部署方便局限性小，因为是静态页面，因此只需要提供一个能访问的web空间即可，目前大部分的git平台都 免费 提供这么一个服务，让用户可以将静态页面托管在服务器上提供外部访问 对于静态博客而言，方便部署是一个优势，但静态页面总会缺乏交互性，没有数据库，没有服务器的应答脚本，但是做为普通的个人博客却已经足够了 Hexo静态博客生成工具 Hexo是基于nodejs的一套静态博客生成工具，可以很方便的创建一套静态博客框架，并基于博客内容生成静态页面，官网网站也提供一些常用的Hexo主题。 常用指令 hexo init [folder] 在指定目录下，初始化一套博客框架 hexo new [layout] &lt;title&gt; 新建博客文档 hexo generate 生成静态页面 hexo server 在本地开启web站点，用于本地查看页面效果 hexo deploy 将博客的静态页面部署至外网服务器 解决博客响应速度慢问题最开始我的博客都是放在github上进行托管，但是github对于国内而言，访问速度总不是特别理想，有朋友反馈说打不开我的博客，我一想大概就知道是github的响应慢导致的，于是就想把博客托管在多个平台上，对外提供访问，选来选去，还是选择了coding做为国内博客托管平台, 主要原因还是之前用过coding。 要想博客分担在不同的平台上，域名还只有一个，想了想，我的域名托管服务平台提供智能DNS，默认访问coding平台，国外IP访问github平台，完美解决。","categories":[{"name":"Unclassified","slug":"Unclassified","permalink":"https://oldchan.net/categories/Unclassified/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://oldchan.net/tags/博客/"}],"keywords":[{"name":"Unclassified","slug":"Unclassified","permalink":"https://oldchan.net/categories/Unclassified/"}]},{"title":"ShellCode For LoadLibrary","slug":"windows/rootkit/shellcode","date":"2016-05-12T02:28:28.000Z","updated":"2021-02-24T05:00:52.016Z","comments":true,"path":"2016/05/12/windows/rootkit/shellcode/","link":"","permalink":"https://oldchan.net/2016/05/12/windows/rootkit/shellcode/","excerpt":"方便快速注入插件，又增加可移植性，将必要的系统接口通过参数传递到函数内 使用时正确初始化参数，然后将函数的内存code与参数一起拷贝到指定进程中 LoadClientLibrary使用裸函数约定，结束标志方便定位函数总内存长度","text":"方便快速注入插件，又增加可移植性，将必要的系统接口通过参数传递到函数内 使用时正确初始化参数，然后将函数的内存code与参数一起拷贝到指定进程中 LoadClientLibrary使用裸函数约定，结束标志方便定位函数总内存长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#pragma pack(push, 1)typedef struct &#123; DWORD SizeOfParameter: 32; CHAR Buffer[1024];&#125; CALLBACK_PROC_PARAMETER, *PCALLBACK_PROC_PARAMETER;typedef struct &#123; /* 系统接口 */ HMODULE (WINAPI *LoadLibrary)(__IN LPCSTR); FARPROC (WINAPI *GetProcAddress)(__IN HMODULE, __IN LPCSTR); /* 注入信息 */ CHAR InjectLibrary[MAX_PATH]; CHAR InjectProcedure[100]; CALLBACK_PROC_PARAMETER CommandLine;&#125; REMOTE_THREAD_PARAM, *PREMOTE_THREAD_PARAM;#pragma pack(pop)__NAKED BOOL WINAPI LoadClientLibrary(__IN PREMOTE_THREAD_PARAM lpThreadParameter)&#123; __asm &#123; // 函数开始 push ebp mov ebp, esp // 分配变量 sub esp, 0x08 // [ebp - 0x04]: ClientLibrary // [ebp - 0x08]: ClientProcedure &#125; __asm &#123; // 程序代码 xor eax, eax push ebx push ecx push edx push edi push esi mov esi, lpThreadParameter lea eax, [esi + 0x08] push eax call [esi] cmp eax, 0 je __EXIT_LABEL mov [ebp - 0x04], eax lea eax, [esi + 0x0000010C] push eax push [ebp - 0x04] call [esi + 0x04] cmp eax, 0 je __EXIT_LABEL mov [ebp - 0x08], eax lea eax, [esi + 0x00000170] push eax call [ebp - 0x08]__EXIT_LABEL: pop esi pop edi pop edx pop ecx pop ebx &#125; __asm &#123; // 销毁变量 add esp, 0x08 // 函数结束 mov esp, ebp pop ebp &#125; __asm &#123; // 返回并清除堆栈参数 ret 0x04 &#125; // 结束标志 __asm &#123; __emit 0x19 __emit 0x90 __emit 0x04 __emit 0x03 &#125;&#125;","categories":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}],"tags":[{"name":"注入","slug":"注入","permalink":"https://oldchan.net/tags/注入/"}],"keywords":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}]},{"title":"Windows系统服务描述表","slug":"windows/kernel/ke_service_descriptor_table","date":"2014-09-13T07:47:35.000Z","updated":"2021-02-24T10:58:36.863Z","comments":true,"path":"2014/09/13/windows/kernel/ke_service_descriptor_table/","link":"","permalink":"https://oldchan.net/2014/09/13/windows/kernel/ke_service_descriptor_table/","excerpt":"Win32下获取系统服务描述表的方法 123456789101112131415161718192021PSYSTEM_SERVICE_DESCRIPTOR_TABLE KeGetServiceDescriptorTable()&#123; // 结果值 PSYSTEM_SERVICE_DESCRIPTOR_TABLE ServiceDescriptorTable = NULL; __asm &#123; push eax push ebx push OffsetKthreadServiceTable call OffsetGet mov ebx, eax mov eax, dword ptr fs:[0x124] add eax, ebx mov eax, dword ptr [eax] mov ServiceDescriptorTable, eax pop ebx pop eax &#125; return ServiceDescriptorTable;&#125; OffsetGet这个自定义函数是为了兼容多系统版本，根据常量OffsetKthreadServiceTable的值来获取对应偏移 在驱动入口函数DriverEntry中获取的是SSDT，DeviceIoControl访问时，获取的是才是完整版KeServiceDescriptorTable","text":"Win32下获取系统服务描述表的方法 123456789101112131415161718192021PSYSTEM_SERVICE_DESCRIPTOR_TABLE KeGetServiceDescriptorTable()&#123; // 结果值 PSYSTEM_SERVICE_DESCRIPTOR_TABLE ServiceDescriptorTable = NULL; __asm &#123; push eax push ebx push OffsetKthreadServiceTable call OffsetGet mov ebx, eax mov eax, dword ptr fs:[0x124] add eax, ebx mov eax, dword ptr [eax] mov ServiceDescriptorTable, eax pop ebx pop eax &#125; return ServiceDescriptorTable;&#125; OffsetGet这个自定义函数是为了兼容多系统版本，根据常量OffsetKthreadServiceTable的值来获取对应偏移 在驱动入口函数DriverEntry中获取的是SSDT，DeviceIoControl访问时，获取的是才是完整版KeServiceDescriptorTable 12345678910111213141516171819202122232425262728293031323334353637383940/************************************************************************//* 获取系统服务描述表(SSDT Shadow) *//************************************************************************/PSERVICE_TABLE_DESCRIPTOR KeGetServiceDescriptorTableShadow()&#123; PUCHAR Pos; PUCHAR BeginPos = (PUCHAR)KeAddSystemServiceTable; static PSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTableShadow = NULL; // 返回现有值 if(KeServiceDescriptorTableShadow) &#123; return KeServiceDescriptorTableShadow; &#125; // Search for(Pos = BeginPos; Pos &lt; BeginPos + PAGE_SIZE; ++Pos) &#123; if(!MmIsAddressValid(Pos)) &#123; continue; &#125; KeServiceDescriptorTableShadow = (PSERVICE_TABLE_DESCRIPTOR)(*(PULONG)Pos); if (!MmIsAddressValid((PVOID)KeServiceDescriptorTableShadow)) &#123; continue; &#125; else if (memcmp((PVOID)KeServiceDescriptorTableShadow, &amp;KeServiceDescriptorTable[0], sizeof(SERVICE_TABLE_DESCRIPTOR)) == 0) &#123; if ((PVOID)KeServiceDescriptorTableShadow == (PVOID)&amp;KeServiceDescriptorTable[0]) &#123; continue; &#125; return KeServiceDescriptorTableShadow; &#125; &#125; return KeServiceDescriptorTableShadow = NULL;&#125; 2016年新加的获取方式，用的比较多","categories":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}],"tags":[{"name":"Windows内核","slug":"Windows内核","permalink":"https://oldchan.net/tags/Windows内核/"}],"keywords":[{"name":"Technology","slug":"Technology","permalink":"https://oldchan.net/categories/Technology/"}]}]}